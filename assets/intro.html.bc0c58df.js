import{_ as c,r as i,o as l,c as d,a as n,w as s,b as r,d as e,e as t}from"./app.ed3351a4.js";var h="/ast-example.svg";const p={},u=r('<h1 id="get-started" tabindex="-1"><a class="header-anchor" href="#get-started" aria-hidden="true">#</a> Get Started</h1><h2 id="in-browser" tabindex="-1"><a class="header-anchor" href="#in-browser" aria-hidden="true">#</a> In-Browser</h2><p>Wishful thinking. This project is years away. But one can dream: a self-hosting, Wasm-targetting (thus Wasm-implemented) compiler could be distributed entirely via CDN and run in-browser, producing programs that run in-browser. Or the entire compiler could run &quot;serverless&quot;, serving binary responses to Scheme-coded requests, Or, everything could just be compiled to native, etc.</p><h2 id="intro-to-lisp" tabindex="-1"><a class="header-anchor" href="#intro-to-lisp" aria-hidden="true">#</a> Intro to Lisp</h2><p>If you don&#39;t know anything about Lisp, there&#39;s still nothing better than the <a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/index.html" target="_self" rel="noopener noreferrer">wizard book</a>, which takes a light-hearted approach, starts at square one, and is designed to blow your mind. Those who prefer dry brevity should read the entire <a href="/r7rs-small.pdf">language report</a>. Yes, this is Scheme, not Common Lisp. The rest of this &quot;intro&quot; assumes you already know the basics of Lisp.</p><h3 id="it-s-not-about-lists" tabindex="-1"><a class="header-anchor" href="#it-s-not-about-lists" aria-hidden="true">#</a> It&#39;s not about lists</h3><p>Lisp means &quot;<strong>Lis</strong>t <strong>P</strong>rocessor&quot;. This is deceiving.</p><p><a href="/r7rs-small.pdf#section.6.4">The pair</a> may be the simplest form of linked list, consisting of just a value (the <code>car</code>) and a &#39;next&#39;-pointer (the <code>cdr</code>), but I find it better to think of it as a node in a <a href="https://en.wikipedia.org/wiki/Parent_pointer_tree" target="_self" rel="noopener noreferrer">spaghetti stack</a> \u2014 something you can push and pop like a stack, but that splits like a tree. This data structure gently nudges you to implement things recursively / concurrently.</p>',8),m=e("div",{class:"language-scheme ext-scheme line-numbers-mode"},[e("pre",{class:"language-scheme"},[e("code",null,[e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"define"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token function"},"sick-example"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),t(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),f=e("div",{class:"language-scheme ext-scheme line-numbers-mode"},[e("pre",{class:"language-scheme"},[e("code",null,[t("#!sweet  "),e("span",{class:"token comment"},"; https://srfi.schemers.org/srfi-110/srfi-110.html"),t(`

define sick-example`),e("span",{class:"token punctuation"},"("),e("span",{class:"token punctuation"},")"),t(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),g=e("p",null,"It may seem contrived, but the syntax encourages good practice by compelling you to break down functions and expressions into their essential pieces, and compose them together. TODO: Elaborate.",-1),b=e("h3",{id:"more-than-one-type-of-tree",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#more-than-one-type-of-tree","aria-hidden":"true"},"#"),t(" More than one type of tree")],-1),k=e("p",null,[t("The spaghetti stack interpretation is one way of making trees out of Lisp's lists, and using them to guide natural implementations of recursive and concurrent algorithms. But, there's another way to interpret these lists as trees: "),e("em",null,"syntax trees"),t(". We'll use this interpretation to make a hand-wavy argument about why lisp macros are so cool.")],-1),y=e("p",null,[t("Parsing the "),e("a",{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_self",rel:"noopener noreferrer"},"abstract syntax tree"),t(" (AST) from source code is the first job of any compiler. This is the form in which it's considered convenient to transform and inspect code. Consider how you might visualize an AST for this function:")],-1),_=e("div",{class:"language-scheme ext-scheme line-numbers-mode"},[e("pre",{class:"language-scheme"},[e("code",null,[e("span",{class:"token comment"},";;* A basic example of a function definition."),t(`

`),e("span",{class:"token comment"},";; Syntactically, `(f x y)` here is a function call. However,"),t(`
`),e("span",{class:"token comment"},';; when a function "call" appears as the L-value in a definition syntax like this,'),t(`
`),e("span",{class:"token comment"},";; it means the function is being defined rather than invoked."),t(`
`),e("span",{class:"token comment"},";; It's actually just shorthand for `(define f (lambda (x y) ...))`."),t(`
`),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"define"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token function"},"f"),t(" x y"),e("span",{class:"token punctuation"},")"),t(`
  `),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"if"),t(),e("span",{class:"token punctuation"},"("),e("span",{class:"token operator"},"<"),t(" x y"),e("span",{class:"token punctuation"},")"),t(`
    `),e("span",{class:"token punctuation"},"("),e("span",{class:"token keyword"},"begin"),t(`
      `),e("span",{class:"token punctuation"},"("),e("span",{class:"token function"},"display"),t(),e("span",{class:"token string"},'"Under!"'),e("span",{class:"token punctuation"},")"),t(`
      `),e("span",{class:"token punctuation"},"("),e("span",{class:"token operator"},"-"),t(" y x"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),t(`
    `),e("span",{class:"token punctuation"},"("),e("span",{class:"token operator"},"+"),t(" x "),e("span",{class:"token number"},"5"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),e("span",{class:"token punctuation"},")"),t(`
`)])]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),v=e("div",{style:{"background-color":"var(--code-bg-color)"}},[e("img",{src:h,title:"An example syntax tree",style:{display:"block","margin-left":"auto","margin-right":"auto",height:"383px"}})],-1),w=r('<p>Notice how there&#39;s a simple mapping between the AST structure and the source code itself:</p><ul><li>Each AST leaf maps to an atom, like the variable <code>x</code> or the string <code>&quot;Under!&quot;</code>.</li><li>Each subtree has either a function call or <em>syntax</em> (either built-in e.g. <code>define</code>, <code>if</code>, <code>begin</code>; or macros). at the root.</li></ul><p>The distinction between function and syntax is unimportant here because both are written as <a href="https://en.wikipedia.org/wiki/S-expression" target="_self" rel="noopener noreferrer"><em>s-expressions</em></a>. The <code>car</code> is the parent node in the AST, and the <code>cdr</code> is the list of child nodes (each of which could also be a subtree). Whereas the spaghetti stack tree interpretation had children pointing to their parent, this interpretation has parents pointing to their (list of) children. Lisp source code is essentially <em>already</em> in syntax tree form when you write it!</p><p>Not only does this make parsing somewhat simpler for Lisp compilers, it means that Lisp source code is naturally in a form that is relatively easy to transform and analyze programmatically. This is what opens the door to metaprogramming in the form of both the macro system as well as the even more powerful <a href="/r7rs-small.pdf#section.6.12">evaluation mechanism</a>. This is Lisp&#39;s iconic <a href="https://en.wikipedia.org/wiki/Homoiconicity" target="_self" rel="noopener noreferrer">homoiconicity</a>, the property that data and code share a representation, but often that representation is better thought of in terms of trees than lists.</p><p><em>List Processor</em> oversimplifies.</p>',5);function x(T,S){const a=i("CodeGroupItem"),o=i("CodeGroup");return l(),d("div",null,[u,n(o,null,{default:s(()=>[n(a,{title:"Scheme"},{default:s(()=>[m]),_:1}),n(a,{title:"Sweet"},{default:s(()=>[f]),_:1})]),_:1}),g,b,k,y,n(o,null,{default:s(()=>[n(a,{title:"Scheme"},{default:s(()=>[_]),_:1}),n(a,{title:"AST"},{default:s(()=>[v]),_:1})]),_:1}),w])}var q=c(p,[["render",x],["__file","intro.html.vue"]]);export{q as default};
