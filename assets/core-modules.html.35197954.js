import{_ as e,o as t,c as o,b as r}from"./app.ed3351a4.js";const d={},a=r('<h1 id="core-modules" tabindex="-1"><a class="header-anchor" href="#core-modules" aria-hidden="true">#</a> Core Modules</h1><p>All compiled WebScheme programs are Wasm modules. They can either be executable (i.e. no exports, usually a start function), or they represent a <a href="/r7rs-small.pdf#subsection.5.6.1">library definition</a>:</p><ul><li><code>import</code> and <code>export</code> declarations translate to Wasm imports and exports, respectively.</li><li>Any definitions from <code>begin</code>, <code>include</code>, or <code>include-ci</code> declarations translate to global variables or functions.</li><li>Any non-definition expressions from <code>begin</code>, <code>include</code>, or <code>include-ci</code> declarations are evaluated in-order in the start function.</li><li><code>include-library-declarations</code> may similarly add to the start function, and it may also add to the imports / exports.</li></ul><h2 id="type-abi" tabindex="-1"><a class="header-anchor" href="#type-abi" aria-hidden="true">#</a> Type ABI</h2><div class="custom-container warning"><p class="custom-container-title">WARNING</p><p>WebScheme will depend on the final implementation of the <a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md" target="_self" rel="noopener noreferrer">GC proposal</a>, so this design is subject to change.</p></div><table><thead><tr><th style="text-align:right;">Scheme type predicate</th><th style="text-align:left;">Wasm type</th></tr></thead><tbody><tr><td style="text-align:right;"><code>boolean?</code></td><td style="text-align:left;"><code>(type (mut i32))</code></td></tr><tr><td style="text-align:right;"><code>bytevector?</code></td><td style="text-align:left;"><code>(type (array (mut i8)))</code></td></tr><tr><td style="text-align:right;"><code>char?</code></td><td style="text-align:left;"><code>(type (mut i32))</code></td></tr><tr><td style="text-align:right;"><code>eof-object?</code></td><td style="text-align:left;">unary?*</td></tr><tr><td style="text-align:right;"><code>null?</code></td><td style="text-align:left;">unary?*</td></tr><tr><td style="text-align:right;"><code>number?</code></td><td style="text-align:left;"><code>(variant (case &quot;exact&quot; i64) (case &quot;inexact&quot; f64))</code></td></tr><tr><td style="text-align:right;"><code>pair?</code></td><td style="text-align:left;"><code>(type (struct (mut anyref) (mut anyref)))</code></td></tr><tr><td style="text-align:right;"><code>port?</code></td><td style="text-align:left;">TODO</td></tr><tr><td style="text-align:right;"><code>procedure?</code></td><td style="text-align:left;"><code>(type funcref)</code></td></tr><tr><td style="text-align:right;"><code>string?</code></td><td style="text-align:left;"><code>(type (mut string))</code></td></tr><tr><td style="text-align:right;"><code>symbol?</code></td><td style="text-align:left;"><code>(type string)</code></td></tr><tr><td style="text-align:right;"><code>vector?</code></td><td style="text-align:left;"><code>(type (array (mut anyref)))</code></td></tr></tbody></table><p>* <em>Would it be possible to represent unary types with Wasm&#39;s proposed <a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Post-MVP.md#variants" target="_self" rel="noopener noreferrer">&quot;variant&quot; types</a></em>?</p><p>The union of all these types, as well as the common record supertype defined below, is referred to <code>$t-obj</code> and is generally the type of all globals and function parameters and return values (with some exceptions).</p><h3 id="record-types" tabindex="-1"><a class="header-anchor" href="#record-types" aria-hidden="true">#</a> Record Types</h3><p>Ideally, types defined using <a href="/r7rs-small.pdf#section.5.5"><code>define-record-type</code></a> would be implemented using <em>extensible union types</em> as mentioned in the post-MVP section of the <a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md" target="_self" rel="noopener noreferrer">GC proposal</a>.</p>',10),l=[a];function i(s,n){return t(),o("div",null,l)}var p=e(d,[["render",i],["__file","core-modules.html.vue"]]);export{p as default};
